type User @model{
  id: ID!
  username: String!
  email: String!
  image: String
}

type UserRecord @model
@key(fields: ["userID", "exercise"])
@key(name: "byCountry", fields: ["countryID", "exercise", "orm"], queryField: "listRecordsByExerciseAndCountry")
@key(name: "byState", fields: ["stateID", "exercise", "orm"], queryField: "listRecordsByExerciseAndState")
@key(name: "byCity", fields: ["cityID", "exercise", "orm"], queryField: "listRecordsByExerciseAndCity")
@key(name: "byGym", fields: ["gymID", "exercise", "orm"], queryField: "listRecordsByExerciseAndGym")
@key(name: "byUser", fields: ["userID"], queryField: "listRecordsByUser")
{
  userID: ID!
  effortID: ID!
  orm: Int!
  exercise: String!
  countryID: ID!#it's bs but these change
  stateID: ID!
  cityID: ID!
  gymID: ID!
}

type UserLocation @model
@key(fields: ["userID"])
@key(name: "byGym", fields: ["gymID"])
{
  userID: ID!
  gymID: ID!
  gym: Gym @connection(fields: ["gymID"])
}

type UserImage @model
@key(fields: ["userID"])
{
  userID: ID!
  uri: String!
}

#might rename these to be more generic later idk
type Gym @model @searchable {
  id: ID!
  name: String!
  location: Coordinates
  countryID: ID!
  stateID: ID!
  cityID: ID!
  country: Region @connection(fields: ["countryID"])
  state: Region @connection(fields: ["stateID"])
  city: Region @connection(fields: ["cityID"])
}

#essentially this is groups of gyms
#right now i dont care about dover belongs to nh belongs to usa
#a gym will belong to dover, belong to nh, and belong to usa
type Region @model
@key(name: "bySuperRegion", fields: ["superRegionID"])
{
  id: ID!
  superRegionID: ID!
  name: String!
}

type Coordinates {
  lat: Float
  lon: Float
}

input LocationInput{
  lat: Float!
  lon: Float!
}

type GymConnection {
  items: [Gym]
  total: Int
  nextToken: String
}

type Query {
  nearbyGyms(location: LocationInput!, km: Int): GymConnection
}

type Post
@model (subscriptions: {level: public})#, timestamps: {createdAt: "createdOn", updatedAt: "updatedOn"})
@auth(rules:[
  {allow: owner, ownerField: "userID", provider: userPools, operations: [read, create]}
  {allow: private, provider: userPools, operations: [read]}
  {allow: private, provider: iam, operations: [create]}
])
@key(name: "byUser", fields: ["userID"])
@key(name: "SortByTimestamp", fields: ["type", "createdAt"], queryField: "listPostsSortedByTimestamp")
@key(name: "SortByUserAndTimestamp", fields: ["userID", "createdAt"], queryField: "listPostsSortedByUserAndTimestamp")
@searchable
{
  type: String!#this is annoying but its the only way to get all sorted
  id: ID!
  media: [PostMedia] @connection(keyName: "byPost", fields: ["id"])
  title: String
  description: String
  data: String
  userID: ID!
  user: User @connection(fields: ["userID"])
  userImage: UserImage @connection(fields: ["userID"])
  likes: [Like] @connection(keyName: "byParent", fields: ["id"])
  comments: [Comment] @connection(keyName: "byParent", fields: ["id"])
  efforts: [Effort] @connection(keyName: "byPost", fields: ["id"])
  createdAt: String!
}

type Effort
@model
#is this the best way to do it?
@key(name: "byPost", fields: ["postID"])
@key(name: "byUser", fields: ["userID", "exercise", "weight"], queryField: "listEffortsByExerciseAndUser")
{
  id: ID!
  postID: ID!
  userID: ID!
  exercise: String!
  weight: Int!
  reps: Int!
  orm: Int!
  gymID: ID!
  createdAt: String!
  trophies: [Trophy] @connection(keyName: "byEffort", fields: ["id"])
}

#these are kinda like trophies
#if you get a 3rd place trophy, you dont get it taken away when someone else gets 3rd
#its like at the time of the effort, you got 3rd in whereever
#I wonder if theres a way to scan all three by efforts

#personal top 10 effort, at the time
type Trophy
@model
@key(name: "byEffort", fields: ["effortID"])
{
  id: ID!
  effortID: ID!
  type: String!#user, gym, or region
  targetID: ID!#the id of the user, gym, or region
  rank: Int!
}

type Location
@model
#just id for a key fine, right?
@key(name: "bySuperLocation", fields: ["superLocationID"])
{
  id: ID!
  name: String!
  superLocationID: ID!
  superLocation: Location @connection(fields: ["superLocationID"])
}


type Comment
@model
@key(name: "byParent", fields: ["postID"])
#@auth(rules: [{ allow: private, provider: iam, operations: [read, update, delete] }])
{
  id: ID!
  userID: ID!
  postID: ID!
  content: String!
  likes: [Like] @connection(keyName: "byParent", fields: ["id"])
}

type Routine
@model(subscriptions: null)
@key(name: "byUser", fields: ["userID"], queryField: "listRoutinesByUser")
@key(name: "byUserAndCurrent", fields: ["userID", "current"], queryField: "listCurrentRoutinesByUser")
{
  id: ID!
  userID: ID!
  title: String!#do we really need this
  current: Int!#this is dumb but we need to sort on this so its not bool
  routine: String!#json, useful info
  createdAt: String!
  updatedAt: String!
}

#this is for saving the current state of the workout
#in case you want to sync between devices or so
#a user will update and clear a single one of these objects
type CurrentWorkout
@model
@key(fields: ["userID"])
{
  userID: ID!
  data: AWSJSON!
  routineID: ID!
}

type Like
@model
@key(name: "byParent", fields: ["parentID"])
{
  id: ID!
  parentID: ID!
  userID: ID!
}

type PostMedia
@model
@key(name: "byPost", fields: ["postID"])
{
  id: ID!
  postID: ID!
  uri: String!
}

type FollowRelationship
@model
@auth(rules: [
  {allow: owner, ownerField:"followerId", provider: userPools, operations:[read, create]}
  {allow: private, provider: userPools, operations: [read]}
  {allow: private, provider: iam, operations: [read]}
])
@key(fields: ["followeeId", "followerId"])
{
  followeeId: ID!
  followerId: ID!
  createdAt: String!
}

type Timeline
@model
@auth(rules: [
  {allow: owner, ownerField: "userId", provider: userPools, operations: [read, create]},
  {allow: private, provider: iam, operations:[create]}
])
@key(fields: ["userId", "createdAt"])
{
  userId: ID!
  postId: ID!
  post: Post @connection(fields: ["postId"])
  createdAt: String!
}

type Mutation{
  createPostAndTimeline(
    title: String!
    description: String!
    data: String!
  ): Post
  @function(name: "createPostAndTimeline-${env}")
  @auth(rules:[
    {allow: private, provider: userPools},
  ])
}

type Subscription {
  onChangeRoutine(userID: String!): Routine @aws_subscribe(mutations: ["createRoutine", "updateRoutine", "deleteRoutine"])
}
