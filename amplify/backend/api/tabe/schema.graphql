type User @model{
  id: ID!
  username: String!
  email: String!
  image: String
  posts: [Post] @connection(keyName: "byUser", fields: ["id"])
}

type Post
@model (subscriptions: {level: public})#, timestamps: {createdAt: "createdOn", updatedAt: "updatedOn"})
@auth(rules:[
  {allow: owner, ownerField: "userID", provider: userPools, operations: [read, create]}
  {allow: private, provider: userPools, operations: [read]}
  {allow: private, provider: iam, operations: [create]}
])
@key(name: "byUser", fields: ["userID"])
@key(name: "SortByTimestamp", fields: ["type", "createdAt"], queryField: "listPostsSortedByTimestamp")
@searchable
{
  type: String!#this is annoying but its the only way to get all sorted
  id: ID!
  media: [PostMedia] @connection(keyName: "byPost", fields: ["id"])
  title: String
  description: String
  data: String
  userID: ID!
  user: User @connection(fields: ["userID"])
  likes: [Like] @connection(keyName: "byParent", fields: ["id"])
  comments: [Comment] @connection(keyName: "byParent", fields: ["id"])
  createdAt: String!
}

type Effort
@model
#is this the best way to do it?
@key(name: "byCountry", fields: ["countryID", "exercise", "weight"])
@key(name: "byState", fields: ["stateID", "exercise", "weight"])
@key(name: "byCity", fields: ["cityID", "exercise", "weight"])
@key(name: "byGym", fields: ["gymID", "exercise", "weight"])
{
  id: ID!
  postID: ID!
  userID: ID!
  exercise: String!
  weight: Int!
  countryID: ID!
  country: Location @connection(fields: ["countryID"])
  stateID: ID!
  state: Location @connection(fields: ["stateID"])
  cityID: ID!
  city: Location @connection(fields: ["cityID"])
  gymID: ID!
  gym: Location @connection(fields: ["gymID"])
  createdAt: String!
}

type Location
@model
#just id for a key fine, right?
{
  id: ID!
  name: String!
  superLocationID: ID!
  superLocation: Location @connection(fields: ["superLocationID"])
}


type Comment
@model
@key(name: "byParent", fields: ["postID"])
#@auth(rules: [{ allow: private, provider: iam, operations: [read, update, delete] }])
{
  id: ID!
  userID: ID!
  postID: ID!
  content: String!
  likes: [Like] @connection(keyName: "byParent", fields: ["id"])
}

type Routine
@model
@key(name: "byUser", fields: ["userID"])
@key(name: "byUserAndCurrent", fields: ["userID", "current", "createdAt"], queryField: "listCurrentRoutinesByUser")
{
  id: ID!
  userID: ID!
  title: String!#do we really need this
  current: Int!#this is dumb but we need to sort on this so its not bool
  routine: String!#json, useful info
  createdAt: String!
  updatedAt: String!
}

type Like
@model
@key(name: "byParent", fields: ["parentID"])
{
  id: ID!
  parentID: ID!
  userID: ID!
}

type PostMedia
@model
@key(name: "byPost", fields: ["postID"])
{
  id: ID!
  postID: ID!
  uri: String!
}

type FollowRelationship
@model
@auth(rules: [
  {allow: owner, ownerField:"followerId", provider: userPools, operations:[read, create]}
  {allow: private, provider: userPools, operations: [read]}
  {allow: private, provider: iam, operations: [read]}
])
@key(fields: ["followeeId", "followerId"])
{
  followeeId: ID!
  followerId: ID!
  createdAt: String!
}

type Timeline
@model
@auth(rules: [
  {allow: owner, ownerField: "userId", provider: userPools, operations: [read, create]},
  {allow: private, provider: iam, operations:[create]}
])
@key(fields: ["userId", "createdAt"])
{
  userId: ID!
  postId: ID!
  post: Post @connection(fields: ["postId"])
  createdAt: String!
}

type Mutation{
  createPostAndTimeline(
    title: String!
    description: String!
    data: String!
  ): Post
  @function(name: "createPostAndTimeline-${env}")
  @auth(rules:[
    {allow: private, provider: userPools},
  ])
}
